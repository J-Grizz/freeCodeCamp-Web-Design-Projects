<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
    <script defer src="./app.js"></script>
  </head>

  <body>
    <nav class="navbar" id="navbar">
      <header>TypeScript Documentation</header>
      <ul>
        <li><a class="nav-link" href="#Introduction">Introduction</a></li>
        <li>
          <a class="nav-link" href="#TypeScripts_relation_to_other_JavaScript_languages">TypeScript's relation to other
            JavaScript targeting languages</a>
        </li>
        <li>
          <a class="nav-link" href="#Optionally_static_typing_and_type_inference">Optionally static typing and type
            inference</a>
        </li>
        <li><a class="nav-link" href="#Enhanced_IDE_support">Enhanced IDE support</a></li>
        <li><a class="nav-link" href="#Strict_null_checks">Strict null checks</a></li>
        <li>
          <a class="nav-link" href="#Compilation">Compilation</a>
        </li>
        <li><a class="nav-link" href="#JavaScript_interoperability">JavaScript interoperabilitye</a></li>
        <li><a class="nav-link" href="#Converting_from_JavaScript_to_TypeScript">Converting from JavaScript to
            TypeScript</a></li>
        <li><a class="nav-link" href="#Adoption">Adoptions</a></li>
        <li><a class="nav-link" href="#Reference">Reference</a></li>

      </ul>
    </nav>
    <button class="nav-button"></button>
    <main id="main-doc">
      <section class="main-section" id="Introduction">
        <header>Introduction</header>
        <article>
          <p>
            TypeScript is a typed superset of JavaScript that compiles to plain JavaScript - <a
              href="typescriptlang.org"> Official TypeScript website </a>
          </p>
          <p>
            JavaScript is a programming language that is developed by <a href="https://tc39.es/">EMCA's Technical
              Committee 39</a>, which is a group of people composed of many different stakeholders.. TC39 is a committee
            hosted by ECMA: an internal standards
            organization. JavaScript has many different implementations by many different vendors (e.g. Google,
            Microsoft, Oracle, etc.). The goal of JavaScript is to be the lingua franca of the web.
          </p>
          <p>
            TypeScript is a superset of the JavaScript language that has a single open-source compiler and is developed
            mainly by a single vendor: Microsoft. The goal of TypeScript is to help catch mistakes early through a type
            system and to make JavaScript development more efficient.
          </p>
          <p>
            Essentially TypeScript achieves its goals in three ways:
          </p>
          <ol>
            <li>
              <strong>Support for modern JavaScript features</strong> - The JavaScript language (not the runtime) is
              standardized through
              the <a href="https://en.wikipedia.org/wiki/ECMAScript">ECMAScript standards</a>. Not all browsers and
              JavaScript runtimes support all features of all ECMAScript
              standards (see this <a href="https://kangax.github.io/compat-table/es6/">overview</a>). TypeScript allows
              for the use of many of the latest ECMAScript features and
              translates them to older ECMAScript targets of your choosing (see the list of <a
                href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">compile targets</a> under the
              --target compiler option). This means that you can safely use new features, like modoles, lambda
              functions, classes, the spread operator and destructuring, while remaining backwards compatible with older
              browsers and JavaScript runtimes.
            </li>
            <li>
              <strong>Advanced type system</strong> - The type support is not part of the ECMAScript standard and will
              likely
              never be
              due to the interpreted nature instead of compiled nature of JavaScript. The type system of TypeScript is
              incredibly rich and includes: interfaces, enums, hybrid types, generics, union/intersection types, access
              modifiers and much more. The <a href="https://www.typescriptlang.org/">official website</a> of TypeScript
              gives an overview of these features.
              Typescript's type system is on-par with most other typed languages and in some cases arguably more
              powerful.
            </li>
            <li>
              <strong>Developer tooling support</strong> - TypeScript's compiler can run as a background process to
              support both
              incremental compilation and IDE integration such that you can more easily navigate, identify problems,
              inspect possibilities and refactor your codebase.
            </li>
          </ol>
        </article>
      </section>
      <section class="main-section" id="TypeScripts_relation_to_other_JavaScript_languages">
        <header>TypeScript's relation to other JavaScript targeting languages</header>
        <article>
          <p>
            TypeScript has a unique philosophy compared to other languages that compile to JavaScript. JavaScript code
            is valid TypeScript code; TypeScript is a superset of JavaScript. You can almost rename your
            <code>.js</code> files to
            <code>.ts</code> files and start using TypeScript (see "JavaScript interoperability" below). TypeScript
            files are
            compiled to readable JavaScript, so that migration back is possible and understanding the compiled
            TypeScript is not hard at all. TypeScript builds on the successes of JavaScript while improving on its
            weaknesses.
          </p>
          <p>
            On the one hand, you have future proof tools that take modern ECMAScript standards and compile it down to
            older JavaScript versions with Babel being the most popular one. On the other hand, you have languages that
            may totally differ from JavaScript which target JavaScript, like CoffeeScript, Clojure, Dart, Elm, Haxe,
            Scala.js, and a whole host more (see this <a
              href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS"">list</a>). These languages, though they might be better than where
            JavaScript's future might ever lead, run a greater risk of not finding enough adoption for their futures to
            be guaranteed. You might also have more trouble finding experienced developers for some of these languages,
            though the ones you will find can often be more enthusiastic. Interop with JavaScript can also be a bit more
            involved, since they are farther removed from what JavaScript actually is.
          </p>
          <p>
            TypeScript sits in between these two extremes, thus balancing the risk. TypeScript is not a risky choice by
            any standard. It takes very little effort to get used to if you are familiar with JavaScript, since it is
            not a completely different language, has excellent JavaScript interoperability support and it has seen a lot
            of adoption recently.
          </p>
        </article>
      </section>
      <section class=" main-section" id="Optionally_static_typing_and_type_inference">
              <header>Optionally static typing and type inference</header>
              <article>
                <p>
                  JavaScript is dynamically typed. This means JavaScript does not know what type a variable is until it
                  is
                  actually instantiated at run-time. This also means that it may be too late. TypeScript adds type
                  support to
                  JavaScript. Bugs that are caused by false assumptions of some variable being of a certain type can be
                  completely eradicated if you play your cards right (how strict you type your code or if you type your
                  code
                  at all is up to you).
                </p>

                <p>
                  TypeScript makes typing a bit easier and a lot less explicit by the usage of type inference. For
                  example:
                  <code>var x = "hello"</code> in TypeScript is the same as <code>var x : string = "hello"</code>. The
                  type is simply inferred
                  from its
                  use. Even it you don't explicitly type the types, they are still there to save you from doing
                  something
                  which otherwise would result in a run-time error.
                </p>
                <p>
                  TypeScript is optionally typed by default. For example <code>function divideByTwo(x) { return x / 2
                    }</code> is a
                  valid
                  function in TypeScript which can be called with any kind of parameter, even though calling it with a
                  string
                  will obviously result in a runtime error. Just like you are used to in JavaScript. This works, because
                  when
                  no type was explicitly assigned and the type could not be inferred, like in the divideByTwo example,
                  TypeScript will implicitly assign the type <code>any</code>. This means the divideByTwo function's
                  type signature
                  automatically becomes <code>function divideByTwo(x : any) : any</code>. There is a compiler flag to
                  disallow this
                  behavior: <code>--noImplicitAny</code>. Enabling this flag gives you a greater degree of safety, but
                  also means you
                  will
                  have to do more typing.
                </p>
                <p>
                  Types have a cost associated with them. First of all, there is a learning curve, and second of all, of
                  course, it will cost you a bit more time to set up a codebase using proper strict typing too. In my
                  experience, these costs are totally worth it on any serious codebase you are sharing with others. <a>A
                    Large
                    Scale Study of Programming Languages and Code Quality in Github</a> suggests that "statically typed
                  languages,
                  in general, are less defect prone than the dynamic types, and that strong typing is better than weak
                  typing
                  in the same regard".
                </p>
              </article>
      </section>
      <section class="main-section" id="Enhanced_IDE_support">
        <header>Enhanced IDE support</header>
        <article>
          <p>The development experience with TypeScript is a great improvement over JavaScript. The IDE is informed in
            real-time by the TypeScript compiler on its rich type information. This gives a couple of major advantages.
            For example, with TypeScript, you can safely do refactorings like renames across your entire codebase.
            Through code completion, you can get inline help on whatever functions a library might offer. No more need
            to remember them or look them up in online references. Compilation errors are reported directly in the IDE
            with a red squiggly line while you are busy coding. All in all, this allows for a significant gain in
            productivity compared to working with JavaScript. One can spend more time coding and less time debugging.
          </p>

          <p>There is a wide range of IDEs that have excellent support for TypeScript, like Visual Studio Code,
            WebStorm, Atom and Sublime.</p>
        </article>
      </section>
      <section class="main-section" id="Strict_null_checks">
        <header>Strict null checks</header>
        <article>
          <p>
            Runtime errors of the form <code>cannot read property 'x' of undefined</code> or <code>undefined is not
              a function</code> are very
            commonly caused by bugs in JavaScript code. Out of the box TypeScript already reduces the probability of
            these kinds of errors occurring, since one cannot use a variable that is not known to the TypeScript
            compiler (with the exception of properties of <code>any</code> typed variables). It is still possible though
            to
            mistakenly utilize a variable that is set to <code>undefined</code>. However, with the 2.0 version of
            TypeScript you can
            eliminate these kinds of errors all together through the usage of non-nullable types. This works as follows:
          </p>
          <p>
            With strict null checks enabled (<code>--strictNullChecks</code> compiler flag) the TypeScript compiler will
            not allow
            <code>undefined</code> to be assigned to a variable unless you explicitly declare it to be of nullable type.
            For example,
            <code>let x : number = undefined</code> will result in a compile error. This fits perfectly with type theory
            since
            <code>undefined</code> is not a number. One can define <code>x</code> to be a sum type of
            <code>number</code>
            and <code>undefined</code>
            to correct this: <code>let x
              : number | undefined = undefined</code>.
          </p>
          <p>
            Once a type is known to be nullable, meaning it is of a type that can also be of the value <code>null</code>
            or
            <code>undefined</code>, the TypeScript compiler can determine through control flow based type analysis
            whether
            or not
            your code can safely use a variable or not. In other words when you check a variable is
            <code>undefined</code>
            through
            for example an <code>if</code> statement the TypeScript compiler will infer that the type in that branch of
            your code's
            control flow is not anymore nullable and therefore can safely be used. Here is a simple example:
          </p>
          <pre><code>
          let x: number | undefined;
          if (x !== undefined) x += 1; // this line will compile, because x is checked.
          x += 1; // this line will fail compilation, because x might be undefined.
        </code></pre>
          <p>
            During the build, 2016 conference co-designer of TypeScript Anders Hejlsberg gave a detailed explanation and
            demonstration of this feature: <a href="https://channel9.msdn.com/Events/Build/2016/B881">video</a> (from
            44:30 to 56:30).
          </p>
        </article>
      </section>
      <section class="main-section" id="Compilation">
        <header>Compilation</header>
        <article>

          <p>
            JavaScript interoperability
          </p>
          <p>
            To use TypeScript you need a build process to compile to JavaScript code. The build process generally
            takes
            only a couple of seconds depending of course on the size of your project. The TypeScript compiler supports
            incremental compilation (<code>--watch</code> compiler flag) so that all subsequent changes can be
            compiled
            at greater
            speed.
          </p>
          <p>
            The TypeScript compiler can inline source map information in the generated .js files or create separate
            .map
            files. Source map information can be used by debugging utilities like the Chrome DevTools and other IDE's
            to
            relate the lines in the JavaScript to the ones that generated them in the TypeScript. This makes it
            possible
            for you to set breakpoints and inspect variables during runtime directly on your TypeScript code. Source
            map
            information works pretty well, it was around long before TypeScript, but debugging TypeScript is generally
            not as great as when using JavaScript directly. Take the <code>this</code> keyword for example. Due to the
            changed
            semantics of the <code>this</code> keyword around closures since ES2015, <code>this</code> may actually
            exists during runtime as a
            variable called <code>_this</code> (see <a
              href="https://stackoverflow.com/questions/30056593/visual-studio-shows-wrong-value-for-this-in-typescript/30070859#30070859">this
              stackoveflow answer</a>). This may confuse you during debugging but generally is not a
            problem if you know about it or inspect the JavaScript code. It should be noted that Babel suffers the
            exact
            same kind of issue.
          </p>
          <p>
            There are a few other tricks the TypeScript compiler can do, like generating intercepting code based on
            <a
              href="https://stackoverflow.com/questions/29775830/how-to-implement-a-typescript-decorator">decorators</a>,
            generating module loading code for different module systems and parsing <a
              href="https://github.com/Microsoft/TypeScript/wiki/JSX">JSX</a>. However, you will
            likely require a build tool besides the Typescript compiler. For example, if you want to compress your
            code
            you will have to add other tools to your build process to do so.
          </p>
          <p>
            There are TypeScript compilation plugins available for <a
              href="https://github.com/TypeStrong/ts-loader">Webpack</a>, <a
              href="https://www.npmjs.com/package/gulp-typescript">Gulp</a>, <a
              href="https://www.npmjs.com/package/grunt-typescript">Grunt</a> and pretty much any other
            JavaScript build tool out there. The TypeScript documentation has a section on <a
              href="https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html">integrating with
              build
              tools</a>
            covering them all. A <a href="https://www.npmjs.com/package/tslint">linter</a> is also available in case
            you
            would like even more build time checking. There
            are also a great number of seed projects out there that will get you started with TypeScript in
            combination
            with a bunch of other technologies like Angular 2, React, Ember, SystemJS, Webpack, Gulp, etc.
          </p>
        </article>
      </section>
      <section class="main-section" id="JavaScript_interoperability">
        <header>JavaScript interoperabilitye</header>
        <article>
          <p>
            Since TypeScript is so closely related to JavaScript it has great interoperability capabilities, but some
            extra work is required to work with JavaScript libraries in TypeScript. <a
              href="https://www.typescriptlang.org/docs/handbook/namespaces.html">TypeScript definitions</a> are
            needed
            so
            that the TypeScript compiler understands that function calls like <code>_.groupBy</code> or
            <code>angular.copy</code> or <code>$.fadeOut</code> are
            not in fact illegal statements. The definitions for these functions are placed in <code>.d.ts</code>
            files.
          </p>

          <p>
            The simplest form a definition can take is to allow an identifier to be used in any way. For example, when
            using <a href="https://lodash.com/">Lodash</a>, a single line definition file <code>declare var _ :
              any</code> will allow you to call any function you want
            on <code>_</code>, but then, of course, you are also still able to make mistakes: <code>_.foobar()</code>
            would be a legal TypeScript
            call, but is, of course, an illegal call at run-time. If you want proper type support and code completion
            your definition file needs to to be more exact (see <a
              href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/lodash">lodash
              definitions</a>
            for an example).
          </p>
          <p>
            <a href="https://www.npmjs.com/">Npm modules</a> that come pre-packaged with their own type definitions
            are
            automatically understood by the
            TypeScript <a href="https://www.typescriptlang.org/docs/handbook/typings-for-npm-packages.html">compiler</a>
            (see documentation). For pretty much any other semi-popular JavaScript library that does
            not include its own definitions somebody out there has already made type definitions available through
            another npm module. These modules are prefixed with "@types/" and come from a Github repository called
            <a href="https://github.com/DefinitelyTyped/DefinitelyTyped#how-do-i-get-them">DefinitelyTyped</a>.
          </p>
          <p>
            There is one caveat: the type definitions must match the version of the library you are using at run-time.
            If they do not, TypeScript might disallow you from calling a function or dereferencing a variable that
            exists or allow you to call a function or dereference a variable that does not exist, simply because the
            types do not match the run-time at compile-time. So make sure you load the right version of the type
            definitions for the right version of the library you are using.
          </p>
          <p>
            To be honest, there is a slight hassle to this and it may be one of the reasons you do not choose
            TypeScript, but instead go for something like Babel that does not suffer from having to get type
            definitions
            at all. On the other hand, if you know what you are doing you can easily overcome any kind of issues
            caused
            by incorrect or missing definition files.
          </p>
        </article>
      </section>
      <section class="main-section" id="Converting_from_JavaScript_to_TypeScript">
        <header>Converting from JavaScript to TypeScript</header>
        <article>
          <p>
            Any <code>.js</code> file can be renamed to a <code>.ts</code> file and ran through the TypeScript
            compiler
            to get syntactically the
            same JavaScript code as an output (if it was syntactically correct in the first place). Even when the
            TypeScript compiler gets compilation errors it will still produce a .js file. It can even accept
            <code>.js</code> files
            as input with the <code>--allowJs</code> flag. This allows you to start with TypeScript right away.
            Unfortunately,
            compilation errors are likely to occur in the beginning. One does need to remember that these are not
            show-stopping errors like you may be used to with other compilers.
          </p>

          <p>
            The compilation errors one gets in the beginning when converting a JavaScript project to a TypeScript
            project are unavoidable by TypeScript's nature. TypeScript checks all code for validity and thus it needs
            to
            know about all functions and variables that are used. Thus type definitions need to be in place for all of
            them otherwise compilation errors are bound to occur. As mentioned in the chapter above, for pretty much
            any
            JavaScript framework there are <code>.d.ts</code> files that can easily be acquired with the installation
            of
            <a href="https://github.com/DefinitelyTyped/DefinitelyTyped#how-do-i-get-them">DefinitelyTyped
              packages</a>.
            It might, however, be that you've used some obscure library for which no
            TypeScript definitions are available or that you've polyfilled some JavaScript primitives. In that case,
            you
            must supply type definitions for these bits for the compilation errors to disappear. Just create a
            <code>.d.ts</code>
            file and include it in the tsconfig.json's <code>files</code> array, so that it is always considered by
            the
            TypeScript
            compiler. In it declare those bits that TypeScript does not know about as type <code>any</code>. Once
            you've
            eliminated
            all errors you can gradually introduce typing to those parts according to your needs.
          </p>
          <p>
            Some work on (re)configuring your build pipeline will also be needed to get TypeScript into the build
            pipeline. As mentioned in the chapter on compilation there are plenty of good resources out there and I
            encourage you to look for seed projects that use the combination of tools you want to be working with.
          </p>

          <p>
            The biggest hurdle is the learning curve. I encourage you to play around with a small project at first.
            Look
            how it works, how it builds, which files it uses, how it is configured, how it functions in your IDE, how
            it
            is structured, which tools it uses, etc. Converting a large JavaScript codebase to TypeScript is doable
            when
            you know what you are doing. Read this blog for example on <code>converting 600k lines to typescript in 72
              hours</code>).
            Just make sure you have a good grasp of the language before you make the jump.
          </p>
        </article>
      </section>
      <section class="main-section" id="Adoption">
        <header>Adoption</header>
        <article>
          <p>
            TypeScript is open-source (Apache 2 licensed, see <a
              href="https://github.com/Microsoft/TypeScript">GitHub</a>) and backed by Microsoft. <a>Anders
              Hejlsberg</a>, the
            lead architect of C# is spearheading the project. It's a very active project; the TypeScript team has been
            releasing a lot of new features in the last few years and a lot of great ones are still planned to come
            (see
            the <a href="https://github.com/Microsoft/TypeScript/wiki/Roadmap">roadmap</a>).
          </p>

          <p>
            Some facts about adoption and popularity:
          </p>
          <ol>
            <li>
              In the <a href="https://insights.stackoverflow.com/survey/2017#technology">2017 StackOverflow developer
                survey</a> TypeScript was the most popular JavaScript transpiler (9th
              place overall) and won third place in the most loved programming language category.
            </li>
            <li>
              In the <a href="https://2018.stateofjs.com/javascript-flavors/conclusion/">2018 state of js survey</a>
              TypeScript was declared as one of the two big winners in the JavaScript
              flavors category (with ES6 being the other).
            </li>
            <li>
              In the <a href="https://insights.stackoverflow.com/survey/2019">2019 StackOverlow deverloper survey</a>
              TypeScript rose to the 9th place of most popular languages
              amongst professional developers, overtaking both C and C++. It again took third place amongst most the
              most loved languages.
            </li>
          </ol>
        </article>
      </section>
      <section class="main-section" id="Reference">
        <header>Reference</header>
        <article>
          <ul>
            <li>This document was based entirely off of Lodewijk Bogaards <a
                href="https://stackoverflow.com/questions/12694530/what-is-typescript-and-why-would-i-use-it-in-place-of-javascript"
                target="blank">answer on StackOverflow</a>, so be sure to give him a upvote.</li>
          </ul>
        </article>
      </section>
    </main>
  </body>

</html>